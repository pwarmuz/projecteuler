package main

import (
	"fmt"
	"math"
)

const (
	EVEN uint = 2
	ODD  uint = 3
)

func Problem0002() {
	//var sum fibSum
	//fib := sum.Fibonacci(4000000)
	//fib()
	sum := SumTotal(4000000, EVEN)
	fmt.Printf("total %d of fib seq\n", sum)
}

// findN will find the limit of loops
func findN(m uint) int {
	return int(math.Log(float64(m)*math.Sqrt(5)) / math.Log((1+math.Sqrt(5))/2))
}

func Fibonacci() func() uint {
	// This uses Go closures
	var f, s, result uint
	result, f, s = 0, 0, 1

	return func() uint {
		// if the increment assignment happens before the modulo check then the assignment changes to
		// result, f, s = f, s, f+s where result would be assigned as result%2 and fibSum(result) amending f
		result, f, s = f, s, f+s
		return result
	}
}

func SumTotal(limit, terms uint) uint {
	/*  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
	    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
		 By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
	*/
	var sum uint

	n := findN(limit)

	fib := Fibonacci()

	for i := 0; i <= n; i++ {
		result := fib()
		if result%terms == 0 {
			sum += result
		}

	}
	return sum
}

func Sequence(n uint) []uint {
	sequence := make([]uint, 0, n)
	fib := Fibonacci()

	for i := uint(0); i <= n; i++ {
		// if the increment assignment happens before the modulo check then the assignment changes to
		// result, f, s = f, s, f+s where result would be assigned as result%2 and fibSum(result) amending f
		sequence = append(sequence, fib())
	}
	return sequence

}
